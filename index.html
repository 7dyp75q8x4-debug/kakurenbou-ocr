<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‹ãã‚Œã‚“ã¼ OCR â€” Webç‰ˆ</title>

<!-- Tesseract.js v2 CDN (ç°¡å˜ã«ä½¿ãˆã‚‹API) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>

<style>
  :root{
    --bg:#090909;
    --card:#0f0f0f;
    --accent:#0fbf5a;
    --danger:#d23b3b;
    --panel:#1a1a1a;
    --muted:#9aa0a6;
    --white:#fff;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--white); font-family: -apple-system, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Segoe UI", Roboto, sans-serif;}
  .app {
    height:100vh;
    display:grid;
    grid-template-columns: 140px 1fr 320px; /* å·¦:ãŠé¡Œç¸¦åˆ— / ä¸­å¤®:å€™è£œä¸¦ã³ / å³:controls+camera */
    gap:12px;
    padding:12px;
    box-sizing:border-box;
  }

  /* Left column: 5 topic boxes vertically */
  .topics {
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:stretch;
  }
  .topic {
    background:var(--panel);
    border-radius:10px;
    border:3px solid #b71c1c;
    height: calc((100vh - 12*5 - 24) / 5); /* evenly distributed */
    min-height:72px;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
  }
  .topic .label { position:absolute; left:8px; top:8px; font-weight:700; font-size:15px; }
  .topic img { width:100%; height:100%; object-fit:cover; display:block; }

  /* Center column: rows, each with 3 candidate boxes */
  .center {
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:stretch;
  }
  .candidateRow {
    display:flex;
    gap:12px;
    align-items:center;
    background:transparent;
    padding:6px;
    border-radius:8px;
    height: calc((100vh - 12*5 - 24 - 0) / 5); /* match left */
    box-sizing:border-box;
  }
  .candidate {
    flex:1;
    background:#111;
    border-radius:8px;
    border:2px solid #2a2a2a;
    min-height:48px;
    display:flex;
    gap:8px;
    align-items:center;
    padding:8px;
    box-sizing:border-box;
    justify-content:flex-start;
  }
  .candidate img.crop {
    width:84px; height:84px; object-fit:cover; border-radius:6px; border:2px solid #222;
  }
  .candidate .meta {
    margin-left:8px;
    display:flex; flex-direction:column;
  }
  .candidate .meta .num { font-size:20px; font-weight:700; color:var(--accent); }
  .candidate .meta .txt { font-size:14px; color:var(--muted); }

  /* Right column: controls, status, camera */
  .controls {
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:stretch;
  }
  .status {
    background:#121212;
    padding:12px;
    border-radius:10px;
    text-align:center;
    font-weight:700;
    font-size:18px;
    color:var(--muted);
  }
  .status.wait { color:#1e90ff; } /* blue */
  .status.capture { color:var(--danger); } /* red */

  .btnGrid {
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:10px;
  }
  .btn {
    background:#222;
    border-radius:10px;
    border:2px solid #333;
    padding:12px;
    text-align:center;
    font-weight:800;
    font-size:14px;
    cursor:pointer;
    user-select:none;
  }
  .btn.primary { background:linear-gradient(180deg,#0a6bff,#075fd9); color:white; }
  .btn.danger { background:linear-gradient(180deg,#d64545,#b33a3a); color:white; }
  .btn.toggle { background:#2b2b2b; }

  .cameraBox {
    background:#111;
    border-radius:8px;
    border:3px solid #2a2a2a;
    overflow:hidden;
    position:relative;
    aspect-ratio: 1 / 1;
    min-height:180px;
  }
  video#preview {
    width:100%;
    height:100%;
    object-fit:cover;
    transform:scaleX(-1); /* mirror to look natural; removed for env cam below */
  }

  /* result area */
  .results {
    background:linear-gradient(180deg,#0d0d0d,#0a0a0a);
    padding:10px;
    border-radius:8px;
    min-height:120px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .results .row { font-weight:700; color:var(--muted); }

  /* small helper */
  .small { font-size:13px; color:var(--muted); }

  /* responsive tweak */
  @media (max-width:1000px){
    .app { grid-template-columns: 110px 1fr 260px; padding:8px; gap:8px; }
    .candidate img.crop { width:72px; height:72px; }
  }
</style>
</head>
<body>
<div class="app">

  <!-- LEFT: topics -->
  <div class="topics" id="topics">
    <!-- 5 topic slots -->
    <div class="topic" data-index="0"><div class="label">ãŠé¡Œ1</div><div class="placeholder small">æœªã‚»ãƒƒãƒˆ</div></div>
    <div class="topic" data-index="1"><div class="label">ãŠé¡Œ2</div><div class="placeholder small">æœªã‚»ãƒƒãƒˆ</div></div>
    <div class="topic" data-index="2"><div class="label">ãŠé¡Œ3</div><div class="placeholder small">æœªã‚»ãƒƒãƒˆ</div></div>
    <div class="topic" data-index="3"><div class="label">ãŠé¡Œ4</div><div class="placeholder small">æœªã‚»ãƒƒãƒˆ</div></div>
    <div class="topic" data-index="4"><div class="label">ãŠé¡Œ5</div><div class="placeholder small">æœªã‚»ãƒƒãƒˆ</div></div>
  </div>

  <!-- CENTER: candidate rows -->
  <div class="center" id="center">
    <div class="candidateRow" data-index="0">
      <div class="candidate" data-cand="0"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ1</div></div></div>
      <div class="candidate" data-cand="1"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ2</div></div></div>
      <div class="candidate" data-cand="2"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ3</div></div></div>
    </div>
    <div class="candidateRow" data-index="1">
      <div class="candidate" data-cand="0"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ1</div></div></div>
      <div class="candidate" data-cand="1"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ2</div></div></div>
      <div class="candidate" data-cand="2"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ3</div></div></div>
    </div>
    <div class="candidateRow" data-index="2">
      <div class="candidate" data-cand="0"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ1</div></div></div>
      <div class="candidate" data-cand="1"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ2</div></div></div>
      <div class="candidate" data-cand="2"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ3</div></div></div>
    </div>
    <div class="candidateRow" data-index="3">
      <div class="candidate" data-cand="0"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ1</div></div></div>
      <div class="candidate" data-cand="1"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ2</div></div></div>
      <div class="candidate" data-cand="2"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ3</div></div></div>
    </div>
    <div class="candidateRow" data-index="4">
      <div class="candidate" data-cand="0"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ1</div></div></div>
      <div class="candidate" data-cand="1"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ2</div></div></div>
      <div class="candidate" data-cand="2"><img class="crop" src="" alt="" /><div class="meta"><div class="num">-</div><div class="txt">å€™è£œ3</div></div></div>
    </div>
  </div>

  <!-- RIGHT: controls and camera -->
  <div class="controls">
    <div id="status" class="status wait">çŠ¶æ…‹: å¾…æ©Ÿä¸­</div>

    <div class="btnGrid">
      <div id="modeTopic" class="btn toggle">ğŸ“· ãŠé¡Œæ’®å½±ãƒ¢ãƒ¼ãƒ‰</div>
      <div id="modeSearch" class="btn toggle">ğŸ” ç•ªå·æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰</div>

      <div id="captureBtn" class="btn danger">ğŸ”´ é•·æŠ¼ã—ã§æ’®å½±</div>
      <div id="resetBtn" class="btn">â™»ï¸ ãŠé¡Œãƒªã‚»ãƒƒãƒˆ</div>
    </div>

    <div class="cameraBox" id="cameraBox" title="ã‚«ãƒ¡ãƒ©æ˜ åƒ">
      <video id="preview" autoplay playsinline></video>
    </div>

    <div class="results" id="results">
      <div class="row">ãŠé¡Œä¸€è¦§(å·¦ã«è¡¨ç¤ºæ¸ˆã¿): <span id="topicList" class="small">â€”</span></div>
      <div class="row">å€™è£œTOP3ï¼ˆå„ãŠé¡Œã®å³ã«è¡¨ç¤ºï¼‰</div>
      <div class="row small">â€» èªè­˜ã¯ç’°å¢ƒä¾å­˜ã§ã™ã€‚æš—ã„/é ã„/ãƒ–ãƒ¬ã«å¼±ã„ã€‚</div>
    </div>
  </div>

</div>

<!-- Hidden canvas for captures -->
<canvas id="captureCanvas" style="display:none;"></canvas>

<script>
/*
  ä¸»è¦æ©Ÿèƒ½ï¼š
  - ã‚«ãƒ¡ãƒ©èµ·å‹•ï¼ˆèƒŒé¢ / environment æ¨å¥¨ï¼‰
  - ãƒ¢ãƒ¼ãƒ‰: ãŠé¡Œæ’®å½±ãƒ¢ãƒ¼ãƒ‰ / ç•ªå·æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰
  - é•·æŠ¼ã—æ’®å½±: pointerdown ã§1ç§’æ¯ã«é€£å†™ï¼ˆæœ€å¤§ 10 æšï¼‰
  - OCR (Tesseract.js v2) ã§æ•°å­—ã®èª­ã¿å–ã‚Š
  - ãŠé¡Œæ’®å½±ãƒ¢ãƒ¼ãƒ‰: ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ 3 æ¡ã®æ•°å­—ã‚’æ¢ã—ã€å·¦å´ slot ã«é †ã«ã‚»ãƒƒãƒˆï¼ˆæœ€å¤§5ï¼‰
  - ç•ªå·æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰: ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰å…¨ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã€‚ å„ãŠé¡Œæ•°å€¤ã«è¿‘æ¥ã™ã‚‹è‹±å­—ï¼ˆå˜æ–‡å­—ï¼‰ã‚’æ¢ã—ã€Top3ã‚’ç”»åƒä»˜ãã§è¡¨ç¤º
  - UI: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºï¼ˆå¾…æ©Ÿ:é’ / æ’®å½±:èµ¤ï¼‰
*/

const MAX_TOPICS = 5;
let currentMode = 'topic'; // 'topic' or 'search'
let topics = Array(MAX_TOPICS).fill(null); // {num:"123", imgDataUrl:"data:..."} or null
let topicIndexNext = 0; // next free topic slot
let ocrWorker = null;
let isCapturing = false;
let captureIntervalId = null;
let captureFramesLimit = 10;
let captureIntervalMs = 1000;

const preview = document.getElementById('preview');
const canvas = document.getElementById('captureCanvas');
const statusEl = document.getElementById('status');
const modeTopic = document.getElementById('modeTopic');
const modeSearch = document.getElementById('modeSearch');
const captureBtn = document.getElementById('captureBtn');
const resetBtn = document.getElementById('resetBtn');

async function startCamera(){
  try{
    const constraints = { video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio:false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    preview.srcObject = stream;
    // ensure preview not mirrored for env cam
    preview.style.transform = 'scaleX(1)';
  }catch(e){
    alert('ã‚«ãƒ¡ãƒ©èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
    console.error(e);
  }
}

// small helper to set status
function setStatus(stateText, stateClass){
  statusEl.textContent = 'çŠ¶æ…‹: ' + stateText;
  statusEl.className = 'status ' + stateClass;
}

// take single snapshot from video -> returns dataURL and ImageBitmap
function snapshot(){
  const v = preview;
  const w = v.videoWidth;
  const h = v.videoHeight;
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(v, 0, 0, w, h);
  return canvas.toDataURL('image/jpeg', 0.9);
}

// run OCR on an image dataURL and return result.data.words
async function runOCR(dataURL){
  // Tesseract.recognize returns a promise
  // we'll whitelist digits+letters to help
  try{
    const res = await Tesseract.recognize(dataURL, 'eng', {
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    });
    // res.data.words includes bbox info and text/confidence
    return res.data;
  }catch(e){
    console.error('OCR error', e);
    return null;
  }
}

// utility: extract 3-digit numbers from OCR words
function extractThreeDigitNumbers(wordsData){
  if(!wordsData || !wordsData.words) return [];
  const found = [];
  for(const w of wordsData.words){
    const txt = (w.text || '').replace(/\s+/g,'');
    const match = txt.match(/^0?\d{2,3}$/) || txt.match(/^\d{3}$/);
    // We only want exactly 3 digits (including leading zeros if shown). Accept "062" etc.
    if(/^\d{3}$/.test(txt)){
      found.push({text:txt, bbox:w.bbox, conf: w.confidence || w.conf});
    }
  }
  // dedupe by text
  const unique = [];
  const seen = new Set();
  for(const f of found){
    if(!seen.has(f.text)){ seen.add(f.text); unique.push(f); }
  }
  return unique;
}

// helper: crop area from current canvas based on bbox and return dataURL
function cropFromCanvas(bbox, padding = 10){
  // bbox: {x0,y0,x1,y1} in Tesseract v2 it's like bbox.x0,y0,x1,y1
  const w = canvas.width, h = canvas.height;
  const x0 = Math.max(0, Math.floor(bbox.x0 - padding));
  const y0 = Math.max(0, Math.floor(bbox.y0 - padding));
  const x1 = Math.min(w, Math.ceil(bbox.x1 + padding));
  const y1 = Math.min(h, Math.ceil(bbox.y1 + padding));
  const cw = x1 - x0, ch = y1 - y0;
  const tmp = document.createElement('canvas');
  tmp.width = cw; tmp.height = ch;
  const ctx = tmp.getContext('2d');
  ctx.drawImage(preview, x0, y0, cw, ch, 0, 0, cw, ch);
  return tmp.toDataURL('image/jpeg', 0.9);
}

// assign topic: number string + img crop
function assignTopic(numText, imgDataUrl){
  if(topicIndexNext >= MAX_TOPICS) {
    console.log('ã™ã§ã«æœ€å¤§æ•° (5) ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™');
    return false;
  }
  topics[topicIndexNext] = {num: numText, img: imgDataUrl};
  topicIndexNext++;
  refreshTopicsUI();
  return true;
}

function refreshTopicsUI(){
  // left topics
  const topicEls = document.querySelectorAll('.topic');
  for(let i=0;i<MAX_TOPICS;i++){
    const t = topicEls[i];
    const data = topics[i];
    t.innerHTML = '<div class="label">ãŠé¡Œ' + (i+1) + '</div>';
    if(data){
      const img = document.createElement('img');
      img.src = data.img;
      t.appendChild(img);
    } else {
      const ph = document.createElement('div');
      ph.className = 'placeholder small';
      ph.textContent = 'æœªã‚»ãƒƒãƒˆ';
      t.appendChild(ph);
    }
  }
  // center candidate top summary: topicList text
  const topicList = topics.map(t => t ? t.num : 'â€”').join(' / ');
  document.getElementById('topicList').textContent = topicList;
}

// set candidate UI for a given topic index with array of candidates [{letter:'A', img:..., conf:...}, ...]
function setCandidatesForTopic(topicIdx, candidates){
  const row = document.querySelector('.candidateRow[data-index="'+topicIdx+'"]');
  if(!row) return;
  for(let i=0;i<3;i++){
    const candEl = row.querySelector('.candidate[data-cand="'+i+'"]');
    const imgEl = candEl.querySelector('img.crop');
    const numEl = candEl.querySelector('.num');
    const txtEl = candEl.querySelector('.txt');
    if(candidates && candidates[i]){
      imgEl.src = candidates[i].img || '';
      numEl.textContent = candidates[i].letter || '-';
      txtEl.textContent = 'conf:'+ (Math.round((candidates[i].conf||0)*10)/10);
    } else {
      imgEl.src = '';
      numEl.textContent = '-';
      txtEl.textContent = 'â€”';
    }
  }
}

// reset all topics and candidates
function resetAll(){
  topics = Array(MAX_TOPICS).fill(null);
  topicIndexNext = 0;
  for(let i=0;i<MAX_TOPICS;i++) setCandidatesForTopic(i, null);
  refreshTopicsUI();
}

// long press capture handling
let holdStart = null;
let capturedCount = 0;
async function startLongPressCapture(){
  if(isCapturing) return;
  isCapturing = true;
  capturedCount = 0;
  setStatus('æ’®å½±ä¸­', 'capture');
  captureIntervalId = setInterval(async ()=>{
    if(capturedCount >= captureFramesLimit) {
      stopLongPressCapture();
      return;
    }
    capturedCount++;
    // snapshot
    const dataUrl = snapshot();
    // show small feedback (could flash)
    console.log('captured frame', capturedCount);
    // depending on mode, do different things:
    if(currentMode === 'topic'){
      // run OCR and try extract 3-digit numbers; set topics automatically (first-come)
      const ocr = await runOCR(dataUrl);
      const nums = extractThreeDigitNumbers(ocr);
      console.log('nums found', nums);
      for(const n of nums){
        // crop area around numeric bbox for topic image
        const crop = cropFromCanvas(n.bbox, 18);
        // assign if slot available and not duplicate
        if(topicIndexNext < MAX_TOPICS && !topics.some(t=>t && t.num === n.text)){
          assignTopic(n.text, crop);
        }
      }
    } else {
      // in search mode: run OCR and for each existing topic, find nearby letter tiles
      const ocr = await runOCR(dataUrl);
      // build list of letter boxes (single-letter words)
      if(!ocr) { console.log('ocr empty'); return; }
      const words = ocr.words || [];
      // create array of letter words with bbox and confidence and text filtered to 1-letter alpha
      const letters = words.filter(w=>{
        const t = (w.text||'').trim();
        return /^[A-Z]$/i.test(t) && w.bbox;
      }).map(w=>({letter: w.text.trim().toUpperCase(), bbox: w.bbox, conf:w.confidence || w.conf}));
      // for each topic, find nearest letters by euclidean distance between centers
      for(let ti=0; ti<MAX_TOPICS; ti++){
        const top = topics[ti];
        if(!top) continue;
        // For this topic, we try to locate the numeric tile on the game screen by looking for words that equal the number.
        const nums = words.filter(w=>{
          const t = (w.text||'').replace(/\s+/g,'');
          return /^\d{3}$/.test(t);
        });
        // If we can find the exact number on the game screen, use its bbox as anchor, else fallback: search across whole screen and pick nearest letters by position
        let anchor = null;
        for(const nn of nums){
          if(nn.text && nn.text.replace(/\s+/g,'') === top.num){
            anchor = nn.bbox;
            break;
          }
        }
        // If no anchor, skip or try to find similar numbers
        if(!anchor){
          // skip for now
          continue;
        }
        // compute centers
        function center(b){ return {x: (b.x0 + b.x1)/2, y: (b.y0 + b.y1)/2}; }
        const aC = center(anchor);
        // measure distance to each letter
        const lettersWithDist = letters.map(l=>{
          const c = center(l.bbox);
          const dx = c.x - aC.x, dy = c.y - aC.y;
          const d = Math.sqrt(dx*dx + dy*dy);
          return {...l, dist:d};
        }).sort((a,b)=>a.dist - b.dist);
        // take top3
        const top3 = lettersWithDist.slice(0,3).map(item=>{
          // crop area around letter bbox
          const img = cropFromCanvas(item.bbox, 14);
          return {letter:item.letter, img:img, conf:item.confidence || item.conf};
        });
        setCandidatesForTopic(ti, top3);
      }
    }
  }, captureIntervalMs);
}

function stopLongPressCapture(){
  if(!isCapturing) return;
  clearInterval(captureIntervalId);
  isCapturing = false;
  setStatus('å¾…æ©Ÿä¸­', 'wait');
  captureIntervalId = null;
}

// UI binding
modeTopic.addEventListener('click', ()=>{
  currentMode = 'topic';
  modeTopic.classList.add('primary'); modeSearch.classList.remove('primary');
  setStatus('å¾…æ©Ÿä¸­ï¼ˆãŠé¡Œæ’®å½±ãƒ¢ãƒ¼ãƒ‰ï¼‰', 'wait');
});
modeSearch.addEventListener('click', ()=>{
  currentMode = 'search';
  modeSearch.classList.add('primary'); modeTopic.classList.remove('primary');
  setStatus('å¾…æ©Ÿä¸­ï¼ˆç•ªå·æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ï¼‰', 'wait');
});

captureBtn.addEventListener('pointerdown', (e)=>{
  // start long press capture
  startLongPressCapture();
});
captureBtn.addEventListener('pointerup', (e)=>{
  stopLongPressCapture();
});
captureBtn.addEventListener('pointerleave', (e)=>{
  stopLongPressCapture();
});

resetBtn.addEventListener('click', ()=>{
  if(confirm('æœ¬å½“ã«ãŠé¡Œã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) resetAll();
});

// initialize
(async function init(){
  // start camera
  await startCamera();
  // default UI
  modeTopic.classList.add('primary'); setStatus('å¾…æ©Ÿä¸­', 'wait');
  refreshTopicsUI();
})();
</script>
</body>
</html>
